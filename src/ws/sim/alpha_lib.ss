
;;;; .title Simulator Alpha Run-time Support Library
;;;; These are run-time functions used by code generated by compile-simulate-alpha.

; =======================================================================

; [2005.09.29] Moved start-alpha-sim and some other global bindings
; and helpers to simulator_alpha.ss

(module alpha_lib mzscheme
  (require 
   "../constants.ss"  
   "../compiler_components/logfiles.ss"
   "../../plt/hashtab.ss"
   (all-except "../util/helpers.ss" test-this these-tests)
   (all-except "../compiler_components/wavescript_helpers.ss" test-this these-tests filter)

   ;; Would like to remove this dependency eventually:
   (all-except "simulator_alpha_datatypes.ss") ;run-alpha-simple-scheduler)
   )
  
  (provide 

	 get-connectivity get-node get-simobject ;; Utilities for coercion:         
         attempt-message-transmission

   	 current-simobject

	 retrieve-token
	 add-token
	 evict-token	 
	 evict-all-tokens

         
	 neighbors
	 sendmsg

	 sim-print-queue
	 sim-light-up
         sim-highlight-edge
	 sim-draw-mark
	 sim-leds
         sim-setlabel
	 ;sim-dist
	 sim-loc
	 sim-locdiff         
	 simulator-soc-return
	 simulator-soc-finished
	 check-store
	 ;alpha-it ;; shorthand

	 alist_update
	 alist_lookup

         sim-print

	 test-alphalib   
;           (all-from "simulator_alpha.ss"))
   )

  (chezimports )
  
  (IFCHEZ (begin)
	  (begin 
	    (IF_GRAPHICS (require (all-except "basic_graphics.ss" test-this these-tests)))
	    (IF_GRAPHICS (require (all-except "graphics_stub.ss" test-this these-tests)))))

; =======================================================================

;; The code below does not exist within the scope of the "this"
;; parameter to node-code.  Node-code is kind enough to set this
;; global parameter correctly, so that the current simobject may be
;; accessed by the below library code. -[2005.10.16]
;; NOTE: this is not a "wavescript-parameter" because it should not be user-adjustable.
(define current-simobject (reg:make-parameter 'current-simobject_uninitialized!))

; =======================================================================
;;; Helpers for accessing global simulation data structures.

;; [2006.01.25] <br>
;; A convenient function for getting the current connectivity between two node-ids.<br>
;; Gets the information from the (simalpha-current-simworld) param. 
;; Or uses an optional world parameter.
(define (get-connectivity n1 n2 . sim)
  (let ([sim (if (null? sim) 
		 (simalpha-current-simworld)
		 (car sim))])
    (let ([n1 (get-node n1)]
	  [n2 (get-node n2)])
      ((simworld-connectivity-function sim)
       (node-pos n1) 
       (node-pos n2)))))

;; [2006.01.25] <br>
;; A convenient function for coercing an ID number, simobject, or node-obj into a node-obj.<br>
;; Gets the information from the (simalpha-current-simworld) param. 
;; Or uses an optional world parameter.
(define (get-node ob . sim)
  (cond
   [(integer? ob)
    (let ([sim (if (null? sim) 
		   (simalpha-current-simworld)
		   (car sim))])
      (simobject-node (hashtab-get (simworld-obj-hash sim) ob)))]
   [(simobject? ob)
    (simobject-node ob)]
   [(node? ob) ob]
   [else (error 'get-node "cannot coerce this object to a node: ~a" ob)]))

;; [2006.01.25] <br>
;; A convenient function for coercing an ID number, simobject, or node-obj into a simobject.<br>
;; Gets the information from the (simalpha-current-simworld) param. 
;; Or uses an optional world parameter.
(define (get-simobject ob . sim)
  (cond
   [(integer? ob)
    (let ([sim (if (null? sim) 
		   (simalpha-current-simworld)
		   (car sim))])
      (hashtab-get (simworld-obj-hash sim) ob))]
   [(simobject? ob) ob]
   [(node? ob) (get-simobject (node-id ob))]
   [else (error 'get-node "cannot coerce this object to a simobject: ~a" ob)]))

; =======================================================================

;;; Channel modeling.

;; This function abstracts the modeling of the channel.  This
;; simulates the attempted transmission of a message, and returns true
;; or false based on whether it succeeded.  This could be arbitrarily
;; more complex.
(define (attempt-message-transmission p1 p2)
  (let ((connectivity ((simworld-connectivity-function (simalpha-current-simworld))
		       (node-pos (get-node p1))
		       (node-pos (get-node p2)))))
#;
    (printf "Checking connectivity: ~s ~s ~s\n"
	    connectivity
	    (simobject-node ob)
	    (simobject-node nbr))
    (cond
     [(fixnum? connectivity)
      (fx< (reg:random-int 100) connectivity)]
     [(procedure? connectivity)
      (fx< (reg:random-int 100) (connectivity (simworld-vtime (simalpha-current-simworld))))]
     [else 
      (error 'launch-outgoing "bad connectivity function result: ~s" connectivity)])))

; =======================================================================
;; Node level utilities 

;; [2005.10.29] These three are the interface through which the token-store is accessed.
(define (retrieve-token the-store stok)
  ;; This is defined lamely because equal? doesn't work on records.
  (let ((ls (hashtab-get the-store (token->key stok))))
;    (inspect (cons ls stok))
    (if (not ls) #f
	(let loop ((ls ls))
	  (cond 
	   [(null? ls) #f]
	   [(simtok-equal? (caar ls) stok)  (cdar ls)]
	   [else (loop (cdr ls))])))))

(define (evict-token the-store stok)
  (let* ([key (token->key stok)]
	 [ls (hashtab-get the-store key)]
	 [newls (filter (lambda (x) (not (simtok-equal? (car x) stok))) ls)])
    (if (null? newls)
	(hashtab-remove! the-store key)
	(hashtab-set! the-store key newls))))

(define (evict-all-tokens the-store stok)
  (let ([name (simtok-name stok)]
	[keys '()])
    (hashtab-for-each
     (lambda (k pr)
       (if (eq? name (simtok-name (key->token k)))
	   (set! keys (cons k keys))))
     the-store)
    (for-each (lambda (k)
		(hashtab-remove! the-store k))
      keys)))
	 
;; Returns: unspecified
(define (add-token the-store stok val)
  (let* ([key (token->key stok)]
	 [ls (hashtab-get the-store key)])
    (hashtab-set! the-store key 
		  (cons (cons stok val) 
			(if ls ls ())))))

;; MAKE SURE NOT TO INCLUDE OURSELVES:
;;     SimOb,  [SimWorld] -> (SimOb ...)
;; OR  NodeID, [SimWorld] -> (NodeID ...)
(define (neighbors obj . sim)
  (let ([sim (if (null? sim) (simalpha-current-simworld) (car sim))])
    (if (simobject? obj)
	(let ((entry (assq obj (simworld-object-graph sim))))
	  (if (null? entry)
	      (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
		     obj (simworld-object-graph sim))
	      (begin 
		(if (memq obj (cdr entry))
		    (error 'neighbors "we're in our own neighbors list"))
		(cdr entry))))
	(error 'neighbors "expects simobject: ~s" obj))))

(define sendmsg (lambda (data ob)
                  (set-simobject-incoming-msg-buf! ob
                                           (cons data (simobject-incoming-msg-buf ob)))
                  ;(set-simobject-redraw! ob #t)
                  ))

(define (sim-highlight-edge nbr . extra)
  (IF_GRAPHICS
   (if (integer? nbr)
       (let ((g (simobject-gobj (current-simobject))))
         (when g 
           (let ((pr (assq nbr (gobject-edgelist g))))
             (if pr 
                 ;; This calls the actual graphics procedure:
                 (apply highlight-edge (cadr pr) extra)
                 (warning 'sim-highlight-edge 
                          "tried to highlight an edge to non-connected neighbor: ~s" nbr))))))))

;; Again, fizzle if no graphics loaded.
(define (sim-draw-mark . args)
  (IF_GRAPHICS (apply draw-mark args)))
  
(define (sim-light-up r g b)
  ;((sim-debug-logger) "~n~s: light-up ~s ~s ~s" (node-id (simobject-node (current-simobject))) r g b)
  (logger 4 (simworld-vtime (simobject-worldptr (current-simobject)))
	  (node-id (simobject-node (current-simobject))) 'LightUp `[r ,r] `[g ,g] `[b ,b])
  (IF_GRAPHICS 
   (if (simobject-gobj (current-simobject))
       (change-color! 
	(gobject-circ (simobject-gobj (current-simobject)))
	(make-rgb r g b)))
   ;; We're allowing light-up of undrawn objects atm:
					;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
   
   ;; Fizzle if graphics is not enabled.
   (void)))

[define (sim-setlabel str . ob)
  (IF_GRAPHICS 
   (let ((ob (if (null? ob) (current-simobject) (car ob))))
     (let ((g (simobject-gobj ob)))
       (when g
	 (DEBUGMODE (if (not (gobject? g)) (error 'sim-setlabel "found simobject with invalid gobject!\n")))
	 (change-text! (gobject-label (simobject-gobj ob)) str)))
   ;; Fizzle if graphics is not enabled.
     (void)))]

;; todo INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which . ob)
  (let* ([ob (if (null? ob) (current-simobject) (car ob))]
	 [nodeid (node-id (simobject-node ob))]
	 [state-table (simworld-led-toggle-states (simobject-worldptr ob))]
	 [led-toggle-state (let ((entry (hashtab-get state-table nodeid)))
			     (if entry entry
				 (begin (hashtab-set! state-table nodeid ())
					())))]
         )
;    (disp (node-id (simobject-node ob))
;	  "sim-leds " what which (hashtab->list state-table)) (flush-output-port (current-output-port))
    (let ([extra (case what
                            [(on) 
                             (set! led-toggle-state (list-rem-dups (cons which led-toggle-state)))
                             '()]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             '()]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   '(off))
                                 (begin 
                                   (set! led-toggle-state (list-rem-dups (cons which led-toggle-state)))
                                   '(on))
                                 )]
                            [else (error 'sim-leds "bad action: ~s" what)])])
      ;; Now color the actual leds:
      (IF_GRAPHICS
       (let ((g (simobject-gobj ob)))
	 (if g ;; Do nothing if there's no gobj.
	     (if (memq which led-toggle-state)
		 (case which
		   [(red)   (change-color! (gobject-rled g) (make-rgb 255 0 0))]
		   [(green) (change-color! (gobject-gled g) (make-rgb 0 255 0))]
		   [(blue)  (change-color! (gobject-bled g) (make-rgb 0 0 255))]
		   [else (error 'sim-leds "bad led color: ~s" which)])
		 (case which
		   [(red)   (change-color! (gobject-rled g) (make-rgb 0 0 0))]
		   [(green) (change-color! (gobject-gled g) (make-rgb 0 0 0))]
		   [(blue)  (change-color! (gobject-bled g) (make-rgb 0 0 0))]
		   [else (error 'sim-leds "bad led color: ~s" which)])))))

      ; Finally, commit changes back to the global table of led-states:
      (hashtab-set! state-table nodeid led-toggle-state)

      (logger 4 (simworld-vtime (simobject-worldptr (current-simobject)))
	      nodeid 'Leds `(,which ,what ,@extra))

      ))]

#;
[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache (current-simobject)) (token->key (car tok)))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node (current-simobject)))]

[define (sim-locdiff a b)
  ;(flonum->fixnum ;; TEMP: FIXME: SHOULD RETURN FLOAT
   (exact->inexact 
    (sqrt (+ (expt (- (car a) (car b)) 2)
	     (expt (- (cadr a) (cadr b)) 2))))
   ;)
   ]


(define (alist_lookup ls x)
  (let loop ([ls ls])
    (cond
     [(null? ls) '()]
     [(equal? (vector-ref (car ls) 0) x) ls]
     [else (loop (cdr ls))])))
(define (alist_update origls x y)
  (let loop ([ls origls] [acc '()])
    (cond
     [(null? ls) (cons (vector x y) origls)]
     [(equal? (vector-ref (car ls) 0) x)
      (append (reverse! acc) (cons (vector x y) (cdr ls)))]
     [else (loop (cdr ls) (cons (car ls) acc))])))

[define (sim-print . args) 
  (apply printf args)]
[define (sim-dbg . args) (apply printf args)]

[define (simulator-soc-return x)
  (let ([vtime (simworld-vtime (simobject-worldptr (current-simobject)))])
    ;(fprintf (current-error-port) "~n  SOCRETURN(t=~s) ~s ~n" vtime x)
    (printf "~n  SOCRETURN(t=~s) ~s ~n" vtime x)
    (logger 0 vtime '_ 'SOCRETURN `[val ,x]))
  (soc-return-buffer (cons x (soc-return-buffer)))]

[define (simulator-soc-finished)
  (printf "~nSOC-FINISHED!~n")(flush-output-port (current-output-port))
  ((escape-alpha-sim))]

;; Just for debugging:
[define (sim-print-queue . id)
  (let ([Q (simworld-scheduler-queue (simobject-worldptr (current-simobject)))]
	[format-evt
	 (lambda (evt)
		 (list (simevt-vtime evt)
		       (list (simtok-name (msg-object-token (simevt-msgobj evt)))
			     (simtok-subid (msg-object-token (simevt-msgobj evt))))
		       (msg-object-args (simevt-msgobj evt))))])
  (printf "Current queue: \n")
  (pretty-print
	  (map (lambda (x) (format-evt (car x)))
	       (if (null? id)
		   Q
		   (filter 
		    (lambda (pr) (= (car id)
				    (node-id (simobject-node (cdr pr)))))
		    Q))))
  (printf "  With local messages: \n")
  (pretty-print (map format-evt (simobject-local-msg-buf (current-simobject))))
  (printf "  And incoming messages: \n")
  (pretty-print (map format-evt (simobject-incoming-msg-buf (current-simobject))))
  (printf "  And timed messages: \n")
  (pretty-print (map format-evt (simobject-timed-token-buf (current-simobject))))
  (newline)
  )]


;; Invariant checker: used only in DEBUGMODE
[define (check-store tokstore)
  (hashtab-for-each
   (lambda (key entries)
     (let ((token (key->token key)))
     (or (and (simtok? token) ;(pair? token)
	      (symbol? (simtok-name token)) ;(symbol? (car token))
	      (number? (simtok-subid token)) ;(number? (cdr token))
	      (andmap (lambda (entry)
			(and (pair? entry)
			     (simtok? (car entry))
			     (reg:struct? (cdr entry))))
		      entries)
	      )
	 (error 'check-store "Bad token store at entry: key:~s, token:~s, \n" key token))))
   tokstore)]

;======================================================================

(define-testing these-tests
  `(

    ["Test adding and retrieving tokens to the store."
     (let ((s (make-default-hash-table)))
       (reg:define-struct (foo a b c))
       (apply-ordered list
	(,retrieve-token s (,make-simtok 'foo 0))
	(,add-token s [,make-simtok 'foo 0] [make-foo 0 'let-stored-uninitialized #f])
	(,retrieve-token s [,make-simtok 'foo 0])))
     ,(match-lambda ((,x ,y ,z))
	(and (not x)
	     ; (pair? y) ;; unspecified
	     (reg:struct? z)))]
    ))

(define-testing test-this 
  (default-unit-tester "Alpha Lib. run time library supporting simulator alpha."
    these-tests))
(define test-alphalib test-this)

;; Junk:


;; Uses global "node-code" binding.
#;(define (alpha-repl)
  (printf "sim> ") (flush-output-port (current-output-port))
  (let ((input (read)))
    (unless (eq? 'exit input)
	    (disp "Got prgoram" input)
	    (let ((cleaned (cleanup-token-machine input)))
	      (disp "got cleaned:")(pp cleaned)
	      (alpha-it cleaned)
	      (start-alpha-sim node-code 10.0 'simple)
	      (alpha-repl)))))

) ; End module.